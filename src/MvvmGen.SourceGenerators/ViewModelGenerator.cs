// ***********************************************************************
// ⚡ MvvmGen => https://github.com/thomasclaudiushuber/mvvmgen
// Copyright © by Thomas Claudius Huber
// Licensed under the MIT license => See the LICENSE file in project root
// ***********************************************************************

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using MvvmGen.SourceGenerators.Generators;
using MvvmGen.SourceGenerators.Inspectors;
using MvvmGen.SourceGenerators.Extensions;
using MvvmGen.SourceGenerators.Model;

namespace MvvmGen.SourceGenerators
{
    [Generator]
    public class ViewModelGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
            {
                return;
            }

            var versionString = typeof(ViewModelGenerator).Assembly.GetName().Version.ToString(3);
            var viewModelBaseSymbol = context.Compilation.GetTypeByMetadataName("MvvmGen.ViewModels.ViewModelBase");

            foreach (var viewModelToGenerate in receiver.ViewModelsToGenerate)
            {
                var vmBuilder = new ViewModelBuilder();

                var classSymbol = viewModelToGenerate.ViewModelClassSymbol;
                var namespaceSymbol = classSymbol.ContainingNamespace;

                // Add auto-generated comment
                vmBuilder.AppendLine("// <auto-generated>");
                vmBuilder.AppendLine("//   This code was generated for you by");
                vmBuilder.AppendLine("//   ⚡ MvvmGen => https://github.com/thomasclaudiushuber/mvvmgen");
                vmBuilder.AppendLine($"//   Generator version: {versionString}");
                vmBuilder.AppendLine("// </auto-generated>");

                // Add using directives
                vmBuilder.AppendLine("using System.ComponentModel;");
                vmBuilder.AppendLine("using MvvmGen.Commands;");
                vmBuilder.AppendLine("using MvvmGen.Events;");
                vmBuilder.AppendLine("using MvvmGen.ViewModels;");
                vmBuilder.AppendLine();

                // Add namespace declaration
                if (namespaceSymbol is null)
                {
                    return;
                    // TODO: Show an error here. ViewModel class must be top-level within a namespace
                }

                vmBuilder.AppendLine($"namespace {namespaceSymbol}");
                vmBuilder.AppendLine("{");
                vmBuilder.IncreaseIndent();


                bool inheritFromViewModelBase = false;
                if (viewModelBaseSymbol is not null)
                {
                    inheritFromViewModelBase = !classSymbol.InheritsFromBaseType(viewModelBaseSymbol);
                }

                // Generate class declaration
                vmBuilder.AppendLine($"partial class {classSymbol.Name}" + (inheritFromViewModelBase ? " : ViewModelBase" : ""));
                vmBuilder.AppendLine("{");
                vmBuilder.IncreaseIndent();

                if (viewModelToGenerate.GenerateConstructor)
                {
                    ConstructorGenerator.Generate(vmBuilder, viewModelToGenerate.ViewModelClassSymbol.Name, viewModelToGenerate.InjectionsToGenerate, viewModelToGenerate.CommandsToGenerate?.Any() == true);
                }

                CommandInitializeMethodGenerator.Generate(vmBuilder, viewModelToGenerate.CommandsToGenerate);

                InjectionPropertyGenerator.Generate(vmBuilder, viewModelToGenerate.InjectionsToGenerate);

                CommandPropertyGenerator.Generate(vmBuilder, viewModelToGenerate.CommandsToGenerate);

                ModelPropertyGenerator.Generate(vmBuilder, viewModelToGenerate.WrappedModelType);

                PropertyGenerator.Generate(vmBuilder, viewModelToGenerate.PropertiesToGenerate);

                while (vmBuilder.IndentLevel>1)
                {
                    vmBuilder.DecreaseIndent();
                    vmBuilder.AppendLine("}");
                }

                if (viewModelToGenerate.GenerateViewModelFactory)
                {
                    ViewModelFactoryGenerator.Generate(vmBuilder, viewModelToGenerate.ViewModelClassSymbol, viewModelToGenerate.InjectionsToGenerate);
                }

                while (vmBuilder.DecreaseIndent())
                {
                    vmBuilder.AppendLine("}");
                }

                var sourceText = SourceText.From(vmBuilder.ToString(), Encoding.UTF8);
                context.AddSource($"{namespaceSymbol}.{classSymbol.Name}.g.cs", sourceText);
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }
    }

    class ViewModelBuilder
    {
        private string _indent = "";
        const int _indentSpaces = 4;
        int _indentLevel;
        bool _wasLastCallApendLine = true;

        public ViewModelBuilder()
        {
            StringBuilder = new StringBuilder();
        }

        public StringBuilder StringBuilder { get; }

                public void IncreaseIndent()
        {
            _indentLevel++;
            _indent += new string(' ', _indentSpaces);
        }

        public bool DecreaseIndent()
        {;
            if (_indent.Length >= _indentSpaces)
            {
                _indentLevel--;
                _indent = _indent.Substring(_indentSpaces);
                return true;
            }
            return false;
        }

        public int IndentLevel => _indentLevel;

        bool isFirstMember = true;
        internal void AppendLineBeforeMember()
        {
            if (!isFirstMember)
            {
                StringBuilder.AppendLine();
            }
            isFirstMember = false;
        }

        internal void AppendLine(string line)
        {
            if (_wasLastCallApendLine) // If last call was only Append, you shouldn't add the indent
            {
                StringBuilder.Append(_indent);
            }

            StringBuilder.AppendLine($"{line}");
            _wasLastCallApendLine = true;
        }

        internal void AppendLine()
        {
            StringBuilder.AppendLine();
            _wasLastCallApendLine = true;
        }

        internal void Append(string stringToAppend)
        {
            if (_wasLastCallApendLine)
            {
                StringBuilder.Append(_indent);
                _wasLastCallApendLine = false;
            }
            StringBuilder.Append(stringToAppend);

        }

        public override string ToString() => StringBuilder.ToString();
    }

    internal class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<ViewModelToGenerate> ViewModelsToGenerate { get; } = new();

        /// <summary>
        /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
        /// </summary>
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is ClassDeclarationSyntax
                { AttributeLists: { Count: > 0 } } classDeclarationSyntax)
            {
                var viewModelClassSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);
                var viewModelAttributeData = viewModelClassSymbol?.GetAttributes().SingleOrDefault(x => x.AttributeClass?.ToDisplayString() == "MvvmGen.ViewModelAttribute");

                if (viewModelClassSymbol is not null && viewModelAttributeData is not null)
                {
                    var viewModelToGenerate = new ViewModelToGenerate(viewModelClassSymbol);

                    viewModelToGenerate.InjectionsToGenerate = ViewModelInjectAttributeInspector.Inspect(viewModelClassSymbol);

                    viewModelToGenerate.GenerateConstructor = true;

                    foreach (var arg in viewModelAttributeData.NamedArguments)
                    {
                        if (arg.Key == "GenerateConstructor")
                        {
                            viewModelToGenerate.GenerateConstructor = (bool?)arg.Value.Value == true;
                        }
                    }

                    var viewModelFactoryAttribute = viewModelClassSymbol?.GetAttributes().FirstOrDefault(x => x.AttributeClass?.ToDisplayString() == "MvvmGen.GenerateViewModelFactoryAttribute");
                    if (viewModelFactoryAttribute is not null) {
                        viewModelToGenerate.GenerateViewModelFactory = true;
                        if(viewModelToGenerate.GenerateConstructor)
                        {
                        }

                    }

                    var (commandsToGenerate, propertiesToGenerate) = ViewModelMemberInspector.Inspect(viewModelClassSymbol);
                    viewModelToGenerate.CommandsToGenerate = commandsToGenerate;
                    viewModelToGenerate.PropertiesToGenerate = propertiesToGenerate;

                    viewModelToGenerate.WrappedModelType = ModelMemberInspector.Inspect(viewModelClassSymbol, viewModelAttributeData, propertiesToGenerate);

                    foreach (var propertyToGenerate in propertiesToGenerate)
                    {
                        propertyToGenerate.CommandsToInvalidate = commandsToGenerate
                          .Where(x => x.CanExecuteAffectingProperties is not null
                           && x.CanExecuteAffectingProperties.Contains(propertyToGenerate.PropertyName))
                         .ToList();
                    }

                    viewModelToGenerate.IsEventSubscriber = viewModelClassSymbol.Interfaces.Any(x => x.ToDisplayString().StartsWith("MvvmGen.Events.IEventSubscriber"));

                    ViewModelsToGenerate.Add(viewModelToGenerate);
                }
            }
        }
    }
}
