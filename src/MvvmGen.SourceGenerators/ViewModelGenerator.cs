// ***********************************************************************
// ⚡ MvvmGen => https://github.com/thomasclaudiushuber/mvvmgen
// Copyright © by Thomas Claudius Huber
// Licensed under the MIT license => See the LICENSE file in project root
// ***********************************************************************

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using MvvmGen.SourceGenerators.Generators;
using MvvmGen.SourceGenerators.Inspectors;
using MvvmGen.SourceGenerators.Extensions;
using MvvmGen.SourceGenerators.Model;

namespace MvvmGen.SourceGenerators
{
    [Generator]
    public class ViewModelGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
            {
                return;
            }

            foreach (var viewModelToGenerate in receiver.ViewModelsToGenerate)
            {
                var indentLevel = 0;
                var indentSpaces = 4;
                string indent()
                {
                    return new string(' ', indentLevel * indentSpaces);
                }

                var classSymbol = viewModelToGenerate.ViewModelClassSymbol;
                var namespaceSymbol = classSymbol.ContainingNamespace;

                var stringBuilder = new StringBuilder();

                var versionString = typeof(ViewModelGenerator).Assembly.GetName().Version.ToString(3);

                // Add auto-generated comment
                stringBuilder.AppendLine("// <auto-generated>");
                stringBuilder.AppendLine("//   This code was generated for you by");
                stringBuilder.AppendLine("//   ⚡ MvvmGen => https://github.com/thomasclaudiushuber/mvvmgen");
                stringBuilder.AppendLine($"//   Generator version: {versionString}");
                stringBuilder.AppendLine("// </auto-generated>");

                // Add using directives
                stringBuilder.AppendLine("using System.ComponentModel;");
                stringBuilder.AppendLine("using MvvmGen.Commands;");
                stringBuilder.AppendLine("using MvvmGen.Events;");
                stringBuilder.AppendLine("using MvvmGen.ViewModels;");
                stringBuilder.AppendLine();

                // Add namespace declaration
                if (namespaceSymbol is null)
                {
                    return;
                    // TODO: Show an error here. ViewModel class must be top-level within a namespace
                }

                stringBuilder.AppendLine($"namespace {namespaceSymbol}");
                stringBuilder.AppendLine("{");
                indentLevel++;

                var viewModelBaseSymbol = context.Compilation.GetTypeByMetadataName("MvvmGen.ViewModels.ViewModelBase");

                bool inheritFromViewModelBase = false;
                if (viewModelBaseSymbol is not null)
                {
                    inheritFromViewModelBase = !classSymbol.InheritsFromBaseType(viewModelBaseSymbol);
                }

                // Generate class declaration
                stringBuilder.Append(indent());
                stringBuilder.AppendLine($"partial class {classSymbol.Name}" +
                  (inheritFromViewModelBase ? " : ViewModelBase" : ""));
                stringBuilder.Append(indent());
                stringBuilder.AppendLine("{");
                indentLevel++;
                stringBuilder.AppendLine($"{indent()}protected override void OnInitialize()");
                stringBuilder.AppendLine($"{indent()}{{");
                if (viewModelToGenerate.CommandsToGenerate is not null)
                {
                    foreach (var commandToGenerate in viewModelToGenerate.CommandsToGenerate)
                    {
                        stringBuilder.Append($"{indent()}    {commandToGenerate.CommandName} = new({commandToGenerate.ExecuteMethod}");
                        if (commandToGenerate.CanExecuteMethod is not null)
                        {
                            stringBuilder.Append($", {commandToGenerate.CanExecuteMethod}");
                        }
                        stringBuilder.AppendLine(");");
                    }
                }
                stringBuilder.AppendLine($"{indent()}}}");

                if (viewModelToGenerate.IsEventAggregatorPropertyRequired)
                {
                    EventAggregatorPropertyGenerator.Generate(stringBuilder, indent(),viewModelToGenerate.IsEventSubscriber);
                }

                CommandPropertyGenerator.Generate(viewModelToGenerate.CommandsToGenerate, stringBuilder, indent());

                ModelPropertyGenerator.Generate(viewModelToGenerate.WrappedModelType, stringBuilder, indent());

                PropertyGenerator.Generate(viewModelToGenerate.PropertiesToGenerate, stringBuilder, indent());

                while (indentLevel > 0)
                {
                    indentLevel--;
                    stringBuilder.Append(indent());
                    stringBuilder.AppendLine("}");
                }

                var sourceText = SourceText.From(stringBuilder.ToString(), Encoding.UTF8);
                context.AddSource($"{namespaceSymbol}.{classSymbol.Name}.g.cs", sourceText);
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }
    }

    internal class SyntaxReceiver : ISyntaxContextReceiver
    {
        public List<ViewModelToGenerate> ViewModelsToGenerate { get; } = new();

        /// <summary>
        /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
        /// </summary>
        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is ClassDeclarationSyntax
                { AttributeLists: { Count: > 0 } } classDeclarationSyntax)
            {
                var viewModelClassSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);
                var viewModelAttributeData = viewModelClassSymbol?.GetAttributes()
                  .SingleOrDefault(x => x.AttributeClass?.ToDisplayString() == "MvvmGen.ViewModelAttribute");

                if (viewModelClassSymbol is not null && viewModelAttributeData is not null)
                {
                    var viewModelToGenerate = new ViewModelToGenerate(viewModelClassSymbol);

                    var (commandsToGenerate, propertiesToGenerate) = ViewModelMemberInspector.Inspect(viewModelClassSymbol);
                    viewModelToGenerate.CommandsToGenerate = commandsToGenerate;
                    viewModelToGenerate.PropertiesToGenerate = propertiesToGenerate;

                    viewModelToGenerate.WrappedModelType = ModelMemberInspector.Inspect(viewModelClassSymbol, viewModelAttributeData, propertiesToGenerate);

                    foreach (var propertyToGenerate in propertiesToGenerate)
                    {
                        propertyToGenerate.CommandsToInvalidate = commandsToGenerate
                          .Where(x => x.CanExecuteAffectingProperties is not null
                           && x.CanExecuteAffectingProperties.Contains(propertyToGenerate.PropertyName))
                         .ToList();
                    }

                    viewModelToGenerate.IsEventSubscriber = viewModelClassSymbol.Interfaces.Any(x => x.ToDisplayString().StartsWith("MvvmGen.Events.IEventSubscriber"));

                    ViewModelsToGenerate.Add(viewModelToGenerate);
                }
            }
        }
    }
}
